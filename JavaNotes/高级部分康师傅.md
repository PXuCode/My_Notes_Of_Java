 Java语言层面的高级阶段

## day01

## 多线程

### 多线程基本概念

> ![1573463019934](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573463019934.png)

- 单核与多核的理解

> ![1573470198746](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573470198746.png)

- 使用多线程的优点

- > ![1573470292340](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573470292340.png)

### 线程的创建和使用

- 如何看是否为多线程，一条线是否可以画出来

- 多线程的创建：

- > **方式一：**
  >
  > ![1573471102450](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573471102450.png)
  >
  > start的作用，使得线程开始执行，**启动当前进程，调用当前线程的run（）**，看你是否重写
  >
  > 问题1;不用start，直接run()不可以，虽然可以执行就变为正常的方法执行，而不是并发执行。
  >
  > 问题2：同一个线程只能启动一次，否则会报异常，多线程就造多个对象
  >
  > **方式二：**  
  >
  >  
  >
  > ![1573477532248](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573477532248.png)
  >
  > ![1573477958969](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573477958969.png)
  >
  > 第二种实现接口的卖票方法中，就不需要声明static的变量了，因为**只造了一个对象，放到了三个构造器之中**。
  >
  > 实现类是实现了Runable中国接口，继承是继承了Thread类
  >
  > 两种方式的对比：
  >
  > ![1573479122106](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573479122106.png)
  >
  > 开发中优先使用第二种方式，第二种实现的方式还可以继承，天然地实现共享的数据。
  >
  > 

- Thread常用方法的使用：

- > ![1573473687363](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573473687363.png)
  >
  > 
  >
  > 方法注意事项：
  >
  > 构造器或者setname来设置线程的名字
  >
  > join执行完后才释放处理机。

  - 线程优先级的设置

- > ![1573475115204](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573475115204.png)

  - 线程的生命周期

  > 几种状态
  >
  > ![1573481326493](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573481326493.png)
  >
  > 状态转换
  >
  > ![1573482478178](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573482478178.png)
  >
  >  

  - 理解线程的安全问题;

  >   共享变量

  - 线程安全问题的举例和解决措施

  > ![1573542673715](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573542673715.png)
  >
  > Java中通过同步机制解决线程安全问题，同步代码块，同步方法
  >
  > 解决措施：
  >
  > **方式一**：同步代码块
  >
  > ![1573543112564](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573543112564.png)
  >
  > ![1573544275288](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573544275288.png)
  >
  > 
  >
  > ![1573543178430](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573543178430.png)
  >
  > 这样就不安全了，就不是三个窗口公共同一个锁。就是要同一个对象。
  >
  > 对于同一把锁的说明：实现类的方式中共享了锁，但是在**继承**中，必须要声明锁的对象为**static**，慎重使用，可以使用当前类。
  >
  > 简便的唯一的对象可用，可以使用this保证其唯一即可，比如实现类的创建方式中，就可以使用this，**唯一的类的对象this**。或者练习之中公用的account
  >
  > 另一种写法，拿当前的   **类.class** 也可以，另一个角度看的话类也是对象。
  >
  > ![1573544241248](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573544241248.png)
  >
  > 
  >
  > **方式二**：同步方法

  > ![1573544783545](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573544783545.png)
  >
  > 上面的是解决在实现类的之中，默认使用的是this，没问题。
  >
  > 如果将上面的方法使用在继承之中，this就由三个是不可以的，这是只能考虑将方法写为**静态**的，此时this指向的就是类
  >
  > ![1573545057800](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573545057800.png)
  >
  > 这时候锁就是当前的类.class
  >
  > - 同步方法的**总结**：
  >
  > ![1573545124896](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573545124896.png)
  >
  > 
  >
  > 两种方式可以解决线程的安全问题但是同步代码块变成了单线程问题，效率低。

- 线程安全的单例模式之懒汉模式：

  >  ![1573545396551](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573545396551.png)
  >
  > 不安全之处在于会被两次创建对象，有两个线程且还有共享数据
  >
  > 修改为：
  >
  > ![1573545477112](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573545477112.png)
  >
  > 此时锁就是类.class
  >
  > ![1573545870648](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573545870648.png)
  >
  > 方式二效率高一点

- 两种方式创建匿名线程对象的方法：

  > ![1573547631267](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573547631267.png)
  >
  > 上面为实现类的方法，第一种继承的方法如下
  >
  > ![1573547859552](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573547859552.png)
  >
  > }
  >
  > }.start();
  >
  > 匿名线程
  >
  > 
  >
  > 

### 死锁问题

![1573546940314](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573546940314.png)

- 死锁的例子：康师傅举例：两个线程互相想进锁但是都被对方占有了。

### Lock锁

解决同步问题的方式三

是一个接口，需要有实现类ReentrantLock

![1573548421865](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573548421865.png)

![1573549174400](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573549174400.png)

公平，先进先出

使用方法;

![1573549290649](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573549290649.png)

保证lock之后都是单线程的

- 面试题：synchronized 和 Lock的异同？

  > ![1573549585336](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573549585336.png)
  >
  > 一般都使用synchronized
  >
  > ![1573549659477](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573549659477.png)

- 面试题2：如何解决线程的安全问题？几种方式？

### 线程通信

线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印
 *

 * 涉及到的三个方法：

 * wait():一旦执行此方法，当前线程就进入阻塞状态，并**释放**同步监视器。

 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。

 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。

    

 * 说明：

 * 1.wait()，notify()，notifyAll()三个方法**必须使用在同步代码块或同步方法中**。

 * 2.wait()，notify()，notifyAll()三个方法的**调用者**必须是**同步代码块或同步方法中的同步监视器**。

 * 否则定义一个Object对象时候，就会出现IllegalMonitorStateException异常，或者使用obj.wait(),因为默认的是使用**this**

 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。
    *

 * 面试题：==sleep() 和 wait()的异同==？

 * 1.相同点：一旦执行方法，都可以**使得当前的线程进入阻塞状态**。

 * 2.==不同点==：1）两个方法声明的位置不同：Thread类中声明静态的sleep() , Object类中声明wait()

 * 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中

 * 3）关于是否释放同步监视器：**如果两个方法都使用在同步代码块或同步方法中**，sleep()不会释放锁，wait()会释放锁。sleep会自己醒来，wait不会
   

**wait（）会释放锁，此点和sleep（）有区别**

还得搭配notify或者notifyAll

### jdk8.0新增加的创建进程的方式

方式一：实现Callable接口（JDK5.0新增加的）

![1573568469890](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573568469890.png)

Runnable  run Callable  call

如何创建？

![1573568914196](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573568914196.png)

![1573569064583](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573569064583.png)

```java
/**
 * 创建线程的方式三：实现Callable接口。 --- JDK 5.0新增
 * @author shkstart
 * @create 2019-02-15 下午 6:01
 */
//1.创建一个实现Callable的实现类
class NumThread implements Callable{
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}


public class ThreadNew {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();

        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
            Object sum = futureTask.get();
            System.out.println("总和为：" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

}
```

如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式**强大**？

 * 1. call()可以有返回值的。
 * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
 * 3. Callable是支持泛型的

方式二：线程池（开发中常用此方法）（**练习**）

![1573569919591](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573569919591.png)

如何创建：

```java
    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
//        System.out.println(service.getClass());
//        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();


        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable

//        service.submit(Callable callable);//适合使用于Callable
        //3.关闭连接池
        service.shutdown();
    }
```



## day03

### 复习

- 同步监视器对于多个线程来说是同一个对象即可

- synchronized包含住共享数据的代码，别包多也别少

- 同步方法非静态的时候，锁为当前的类的对象this，如果是静态的方法那么是当前类本身，类就加载一次是唯一的

- 线程安全的单例模式

  两种写法

- 新增加的两种方法：callable和线程池

- > ![1573636228769](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573636228769.png)

- > ![1573636261660](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573636261660.png)

## java常用类

### 目录

> ![1573636416075](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573636416075.png)

### string类

![1573641797089](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573641797089.png)

```java
/*
String:字符串，使用一对""引起来表示。
1.String声明为final的，不可被继承
2.String实现了Serializable接口：表示字符串是支持序列化的。
        实现了Comparable接口：表示String可以比较大小
3.String内部定义了final char[] value用于存储字符串数据
4.String:代表不可变的字符序列。简称：不可变性。
    体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
         2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
         3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。
6.字符串常量池中是不会存储相同内容的字符串的。
 */
```

底层实际是存放到了上面图片中的final字符数组之中

#### String的实例化

字面量定义  常量池

new + 构造器  在堆中，只要是改了一定是新建了一个string

![1573643174322](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573643174322.png)

- 一道小题目

> ![1573643503618](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573643503618.png)
>
> 通过字面量定义了两个对象的name，所以是true

- 一道面试题

> ![1573643684445](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573643684445.png)

#### String不同拼接操作的对比

- 一道**思考题**

> ![1573644329681](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573644329681.png)

#### 一道面试题（**重点）**

> ![1573644886652](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573644886652.png)
>
> output：good best
>
> ![1573645671362](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573645671362.png)
>
> 
>
> 考察的是值传递，基本数据类型传的是值，引用数据类型传递的是地址
>
> 第二个str是地址，不可改变出了方法之后，又变成了之前的字符串并且对象的str是不改变的

### String的常用方法

#### 目录1

![1573646777066](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573646777066.png)

#### 目录2

![1573646798803](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573646798803.png)

#### 目录3

![1573647006458](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573647006458.png)

### String与其他结构的转化

#### String和基本数据类型转换（重点）

![1573647210939](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573647210939.png)

#### String与char[] 转换

- String------>转换为char[ ]

![1573647335382](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573647335382.png)

- char[ ]转换为String调用Sting的构造器即可，要是调用Arrays.toString(),输出的就是原封不动打印数组

![1573647444732](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573647444732.png)

#### String和字节数组之间的转换

![1573649069660](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573649069660.png)

反过来转换仍然是调用构造器，编码解码可以使用**不同的编码解码规则**，不使用默认的就要指定好。

#### String和StringBuffer/StringBuilder的转换

![1573713583803](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573713583803.png)

#### 解决一个拼接的问题

![1573652048938](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573652048938.png)

![1573652036186](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573652036186.png)

加了final就是常量了，拼接之后还是在常量池之中。

### StringBuffer和StringBulider

#### 一道面试题

![1573652705413](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573652705413.png)

StringBuffer线程安全的是因为几乎每个方法就加了synch

#### StringBuffer的源码分析

> 空参构造创建了16长度的数组
>
> 有参数时候，就是abc长度加上16
>
> length返回的是count
>
> ![1573653612569](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573653612569.png)

#### StringBuffer与Builder的方法

> ![1573653699385](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573653699385.png)
>
> Bulider与之类似

#### 三者效率对比

![1573653851909](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573653851909.png)

效率从高到低排列

### JDK8之前的日期时间API

#### currentTimeMillis()

![1573654243903](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573654243903.png)

![1573654455452](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573654455452.png)

返回的是毫秒数，称之为时间戳，计算时间差

#### Date类

在两个地方有![1573654633684](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573654633684.png)

所以自动导包的时候就不知道导入哪一个

- Util之中的

1. > ![1573655043948](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573655043948.png)
   >
   > 或者构造器二
   >
   > ![1573655102604](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573655102604.png)

- java.sql.date

  > 对于数据库之中的时间 
  >
  > ![1573655339899](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573655339899.png)
  >
  > ![1573655786001](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573655786001.png)
  >
  > 强制转换不可以，将父类转换为子类

#### 关于强制转换的几点说明：

![1573655633106](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573655633106.png)

得先创建一个s赋值p，然后向下转型，强制转换，感觉是多态里面的向下转型

![1573655744826](D:\徐鹏\Documents\cloud\我的坚果云\Typora\JavaNotes\JavaSE\1573655744826.png)

new的就是一个父类，转换为子类不可以

## day04

### 每日一考

test一行

阿斯顿

